// Code generated by fin-protoc. DO NOT EDIT.
package com.finproto.sample.messages;

import com.finproto.codec.BinaryCodec;
import com.finproto.codec.ChecksumService;
import com.finproto.codec.ChecksumServiceFactory;
import io.netty.buffer.ByteBuf;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;

public class RootPacket implements BinaryCodec {
  private short msgType;
  private int payloadLen;
  private BinaryCodec payload;
  private int checksum;

  public short getMsgType() {
    return this.msgType;
  }

  public void setMsgType(short msgType) {
    this.msgType = msgType;
  }

  public int getPayloadLen() {
    return this.payloadLen;
  }

  public void setPayloadLen(int payloadLen) {
    this.payloadLen = payloadLen;
  }

  public BinaryCodec getPayload() {
    return this.payload;
  }

  public void setPayload(BinaryCodec payload) {
    this.payload = payload;
  }

  public int getChecksum() {
    return this.checksum;
  }

  public void setChecksum(int checksum) {
    this.checksum = checksum;
  }

  @Override
  public void encode(ByteBuf byteBuf) {
    byteBuf.writeShortLE(this.msgType);
    int payloadLenPos = byteBuf.writerIndex();
    byteBuf.writeIntLE(0);

    int payloadStart = byteBuf.writerIndex();
    if (this.payload != null) {
      this.payload.encode(byteBuf);
    }
    int payloadEnd = byteBuf.writerIndex();
    this.payloadLen = (int) (payloadEnd - payloadStart);
    byteBuf.setIntLE(payloadLenPos, this.payloadLen);
    ChecksumService<ByteBuf, Integer> checksumService =
        ChecksumServiceFactory.getInstance().getChecksumService("CRC32");
    if (checksumService != null) {
      this.checksum = (int) checksumService.calc(byteBuf);
    }
    byteBuf.writeIntLE(this.checksum);
  }

  @Override
  public void decode(ByteBuf byteBuf) {
    this.msgType = byteBuf.readShortLE();
    this.payloadLen = byteBuf.readIntLE();
    this.payload = PayloadMessageFactory.getInstance().create(this.msgType);
    this.payload.decode(byteBuf);
    this.checksum = byteBuf.readIntLE();
  }

  @Override
  public int hashCode() {
    return Objects.hash(msgType, payloadLen, payload, checksum);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (null == obj || getClass() != obj.getClass()) {
      return false;
    }
    RootPacket orther_ = (RootPacket) obj;
    return Objects.equals(msgType, orther_.msgType)
        && Objects.equals(payloadLen, orther_.payloadLen)
        && Objects.equals(payload, orther_.payload)
        && Objects.equals(checksum, orther_.checksum);
  }

  @Override
  public String toString() {
    return "RootPacket ["
        + "msgType="
        + this.msgType
        + ", payloadLen="
        + this.payloadLen
        + ", payload="
        + this.payload
        + ", checksum="
        + this.checksum
        + "]";
  }

  public static enum PayloadMessageFactory {
    INSTANCE;
    private final Map<Short, Supplier<BinaryCodec>> payloadMap = new HashMap<>();

    static {
      getInstance().register((short) 1, BasicPacket::new);
      getInstance().register((short) 2, StringPacket::new);
      getInstance().register((short) 3, NestedPacket::new);
      getInstance().register((short) 4, EmptyPacket::new);
    }

    public BinaryCodec create(Short msgType) {
      Supplier<BinaryCodec> supplier = payloadMap.get(msgType);
      if (null == supplier) {
        throw new IllegalArgumentException("Unsupported MsgType:" + msgType);
      }
      return supplier.get();
    }

    public void register(Short msgType, Supplier<BinaryCodec> supplier) {
      payloadMap.put(msgType, supplier);
    }

    public boolean remove(Short msgType) {
      return null != payloadMap.remove(msgType);
    }

    public static PayloadMessageFactory getInstance() {
      return INSTANCE;
    }
  }
}
