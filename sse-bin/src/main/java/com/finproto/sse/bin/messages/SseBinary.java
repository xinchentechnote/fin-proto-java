// Code generated by fin-protoc. DO NOT EDIT.
package com.finproto.sse.bin.messages;

import com.finproto.codec.BinaryCodec;
import com.finproto.codec.ChecksumService;
import com.finproto.codec.ChecksumServiceContext;
import io.netty.buffer.ByteBuf;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;

public class SseBinary implements BinaryCodec {
  private int msgType;
  private long msgSeqNum;
  private int msgBodyLen;
  private BinaryCodec body;
  private int checksum;

  public int getMsgType() {
    return this.msgType;
  }

  public void setMsgType(int msgType) {
    this.msgType = msgType;
  }

  public long getMsgSeqNum() {
    return this.msgSeqNum;
  }

  public void setMsgSeqNum(long msgSeqNum) {
    this.msgSeqNum = msgSeqNum;
  }

  public int getMsgBodyLen() {
    return this.msgBodyLen;
  }

  public void setMsgBodyLen(int msgBodyLen) {
    this.msgBodyLen = msgBodyLen;
  }

  public BinaryCodec getBody() {
    return this.body;
  }

  public void setBody(BinaryCodec body) {
    this.body = body;
  }

  public int getChecksum() {
    return this.checksum;
  }

  public void setChecksum(int checksum) {
    this.checksum = checksum;
  }

  @Override
  public void encode(ByteBuf byteBuf) {
    byteBuf.writeInt(this.msgType);
    byteBuf.writeLong(this.msgSeqNum);
    int msgBodyLenPos = byteBuf.writerIndex();
    byteBuf.writeInt(0);

    int bodyStart = byteBuf.writerIndex();
    if (this.body != null) {
      this.body.encode(byteBuf);
    }
    int bodyEnd = byteBuf.writerIndex();
    this.msgBodyLen = (int) (bodyEnd - bodyStart);
    byteBuf.setInt(msgBodyLenPos, this.msgBodyLen);
    ChecksumService<ByteBuf, Integer> checksumService =
        ChecksumServiceContext.getChecksumService("SSE_BIN");
    if (checksumService != null) {
      this.checksum = (int) checksumService.calc(byteBuf);
    }
    byteBuf.writeInt(this.checksum);
  }

  @Override
  public void decode(ByteBuf byteBuf) {
    this.msgType = byteBuf.readInt();
    this.msgSeqNum = byteBuf.readLong();
    this.msgBodyLen = byteBuf.readInt();
    this.body = BodyMessageFactory.getInstance().create(this.msgType);
    this.body.decode(byteBuf);
    this.checksum = byteBuf.readInt();
  }

  @Override
  public int hashCode() {
    return Objects.hash(msgType, msgSeqNum, msgBodyLen, body, checksum);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (null == obj || getClass() != obj.getClass()) {
      return false;
    }
    SseBinary orther_ = (SseBinary) obj;
    return Objects.equals(msgType, orther_.msgType)
        && Objects.equals(msgSeqNum, orther_.msgSeqNum)
        && Objects.equals(msgBodyLen, orther_.msgBodyLen)
        && Objects.equals(body, orther_.body)
        && Objects.equals(checksum, orther_.checksum);
  }

  @Override
  public String toString() {
    return "SseBinary ["
        + "msgType="
        + this.msgType
        + ", msgSeqNum="
        + this.msgSeqNum
        + ", msgBodyLen="
        + this.msgBodyLen
        + ", body="
        + this.body
        + ", checksum="
        + this.checksum
        + "]";
  }

  public static enum BodyMessageFactory {
    INSTANCE;
    private final Map<Integer, Supplier<BinaryCodec>> bodyMap = new HashMap<>();

    static {
      getInstance().register((int) 33, Heartbeat::new);
      getInstance().register((int) 40, Logon::new);
      getInstance().register((int) 41, Logout::new);
      getInstance().register((int) 58, NewOrderSingle::new);
      getInstance().register((int) 61, OrderCancel::new);
      getInstance().register((int) 32, Confirm::new);
      getInstance().register((int) 59, CancelReject::new);
      getInstance().register((int) 103, Report::new);
      getInstance().register((int) 204, OrderReject::new);
      getInstance().register((int) 209, PlatformState::new);
      getInstance().register((int) 208, ExecRptInfo::new);
      getInstance().register((int) 206, ExecRptSync::new);
      getInstance().register((int) 207, ExecRptSyncRsp::new);
      getInstance().register((int) 210, ExecRptEndOfStream::new);
    }

    public BinaryCodec create(Integer msgType) {
      Supplier<BinaryCodec> supplier = bodyMap.get(msgType);
      if (null == supplier) {
        throw new IllegalArgumentException("Unsupported MsgType:" + msgType);
      }
      return supplier.get();
    }

    public void register(Integer msgType, Supplier<BinaryCodec> supplier) {
      bodyMap.put(msgType, supplier);
    }

    public boolean remove(Integer msgType) {
      return null != bodyMap.remove(msgType);
    }

    public static BodyMessageFactory getInstance() {
      return INSTANCE;
    }
  }
}
