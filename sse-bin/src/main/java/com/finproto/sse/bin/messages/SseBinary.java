// Code generated by fin-protoc. DO NOT EDIT.
package com.finproto.sse.bin.messages;

import com.finproto.codec.BinaryCodec;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;

public class SseBinary implements BinaryCodec {
  private int msgType;
  private long msgSeqNum;
  private int msgBodyLen;
  private BinaryCodec body;
  private int checksum;

  public int getMsgType() {
    return this.msgType;
  }

  public void setMsgType(int msgType) {
    this.msgType = msgType;
  }

  public long getMsgSeqNum() {
    return this.msgSeqNum;
  }

  public void setMsgSeqNum(long msgSeqNum) {
    this.msgSeqNum = msgSeqNum;
  }

  public int getMsgBodyLen() {
    return this.msgBodyLen;
  }

  public void setMsgBodyLen(int msgBodyLen) {
    this.msgBodyLen = msgBodyLen;
  }

  public BinaryCodec getBody() {
    return this.body;
  }

  public void setBody(BinaryCodec body) {
    this.body = body;
  }

  public int getChecksum() {
    return this.checksum;
  }

  public void setChecksum(int checksum) {
    this.checksum = checksum;
  }

  @Override
  public void encode(ByteBuf byteBuf) {
    byteBuf.writeInt(this.msgType);
    byteBuf.writeLong(this.msgSeqNum);
    ByteBuf bodyBuf = null;
    if (this.body != null) {
      bodyBuf = Unpooled.buffer();
      this.body.encode(bodyBuf);
      this.msgBodyLen = (int) bodyBuf.readableBytes();
    } else {
      this.msgBodyLen = 0;
    }
    byteBuf.writeInt(this.msgBodyLen);

    if (bodyBuf != null) {
      byteBuf.writeBytes(bodyBuf);
      bodyBuf.release();
    }

    byteBuf.writeInt(this.checksum);
  }

  @Override
  public void decode(ByteBuf byteBuf) {
    this.msgType = byteBuf.readInt();
    this.msgSeqNum = byteBuf.readLong();
    this.msgBodyLen = byteBuf.readInt();
    this.body = createBody(this.msgType);
    this.body.decode(byteBuf);
    this.checksum = byteBuf.readInt();
  }

  private static final Map<Integer, Supplier<BinaryCodec>> bodyMap = new HashMap<>();

  static {
    bodyMap.put((int) 33, Heartbeat::new);
    bodyMap.put((int) 40, Logon::new);
    bodyMap.put((int) 41, Logout::new);
    bodyMap.put((int) 58, NewOrderSingle::new);
    bodyMap.put((int) 61, OrderCancel::new);
    bodyMap.put((int) 32, Confirm::new);
    bodyMap.put((int) 59, CancelReject::new);
    bodyMap.put((int) 103, Report::new);
    bodyMap.put((int) 204, OrderReject::new);
    bodyMap.put((int) 209, PlatformState::new);
    bodyMap.put((int) 208, ExecRptInfo::new);
    bodyMap.put((int) 206, ExecRptSync::new);
    bodyMap.put((int) 207, ExecRptSyncRsp::new);
    bodyMap.put((int) 210, ExecRptEndOfStream::new);
  }

  private BinaryCodec createBody(Integer msgType) {
    Supplier<BinaryCodec> supplier = bodyMap.get(msgType);
    if (null == supplier) {
      throw new IllegalArgumentException("Unsupported MsgType:" + msgType);
    }
    return supplier.get();
  }

  @Override
  public int hashCode() {
    return Objects.hash(msgType, msgSeqNum, msgBodyLen, body, checksum);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (null == obj || getClass() != obj.getClass()) {
      return false;
    }
    SseBinary orther_ = (SseBinary) obj;
    return Objects.equals(msgType, orther_.msgType)
        && Objects.equals(msgSeqNum, orther_.msgSeqNum)
        && Objects.equals(msgBodyLen, orther_.msgBodyLen)
        && Objects.equals(body, orther_.body)
        && Objects.equals(checksum, orther_.checksum);
  }

  @Override
  public String toString() {
    return "SseBinary ["
        + "msgType="
        + this.msgType
        + ", msgSeqNum="
        + this.msgSeqNum
        + ", msgBodyLen="
        + this.msgBodyLen
        + ", body="
        + this.body
        + ", checksum="
        + this.checksum
        + "]";
  }
}
