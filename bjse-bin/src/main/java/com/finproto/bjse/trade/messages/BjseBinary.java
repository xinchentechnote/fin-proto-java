// Code generated by fin-protoc. DO NOT EDIT.
package com.finproto.bjse.trade.messages;

import com.finproto.codec.BinaryCodec;
import io.netty.buffer.ByteBuf;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;

public class BjseBinary implements BinaryCodec {
  private int msgType;
  private int bodyLength;
  private BinaryCodec body;
  private int checksum;

  public int getMsgType() {
    return this.msgType;
  }

  public void setMsgType(int msgType) {
    this.msgType = msgType;
  }

  public int getBodyLength() {
    return this.bodyLength;
  }

  public void setBodyLength(int bodyLength) {
    this.bodyLength = bodyLength;
  }

  public BinaryCodec getBody() {
    return this.body;
  }

  public void setBody(BinaryCodec body) {
    this.body = body;
  }

  public int getChecksum() {
    return this.checksum;
  }

  public void setChecksum(int checksum) {
    this.checksum = checksum;
  }

  @Override
  public void encode(ByteBuf byteBuf) {
    byteBuf.writeIntLE(this.msgType);
    int bodyLengthPos = byteBuf.writerIndex();
    byteBuf.writeIntLE(0);

    int bodyStart = byteBuf.writerIndex();
    if (this.body != null) {
      this.body.encode(byteBuf);
    }
    int bodyEnd = byteBuf.writerIndex();
    this.bodyLength = (int) (bodyEnd - bodyStart);
    byteBuf.setIntLE(bodyLengthPos, this.bodyLength);
    byteBuf.writeIntLE(this.checksum);
  }

  @Override
  public void decode(ByteBuf byteBuf) {
    this.msgType = byteBuf.readIntLE();
    this.bodyLength = byteBuf.readIntLE();
    this.body = BodyMessageFactory.getInstance().create(this.msgType);
    this.body.decode(byteBuf);
    this.checksum = byteBuf.readIntLE();
  }

  @Override
  public int hashCode() {
    return Objects.hash(msgType, bodyLength, body, checksum);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (null == obj || getClass() != obj.getClass()) {
      return false;
    }
    BjseBinary orther_ = (BjseBinary) obj;
    return Objects.equals(msgType, orther_.msgType)
        && Objects.equals(bodyLength, orther_.bodyLength)
        && Objects.equals(body, orther_.body)
        && Objects.equals(checksum, orther_.checksum);
  }

  @Override
  public String toString() {
    return "BjseBinary ["
        + "msgType="
        + this.msgType
        + ", bodyLength="
        + this.bodyLength
        + ", body="
        + this.body
        + ", checksum="
        + this.checksum
        + "]";
  }

  public static enum BodyMessageFactory {
    INSTANCE;
    private final Map<Integer, Supplier<BinaryCodec>> bodyMap = new HashMap<>();

    static {
      getInstance().register((int) 1, Logon::new);
      getInstance().register((int) 2, Logout::new);
      getInstance().register((int) 3, Heartbeat::new);
      getInstance().register((int) 101000, NewOrder::new);
      getInstance().register((int) 102000, OrderCancelRequest::new);
      getInstance().register((int) 201000, CancelReject::new);
      getInstance().register((int) 202010, ExecutionConfirm::new);
      getInstance().register((int) 203010, ExecutionReport::new);
      getInstance().register((int) 5, ReportSynchronization::new);
      getInstance().register((int) 6, PlatformStateInfo::new);
      getInstance().register((int) 7, ReportFinished::new);
    }

    public BinaryCodec create(Integer msgType) {
      Supplier<BinaryCodec> supplier = bodyMap.get(msgType);
      if (null == supplier) {
        throw new IllegalArgumentException("Unsupported MsgType:" + msgType);
      }
      return supplier.get();
    }

    public void register(Integer msgType, Supplier<BinaryCodec> supplier) {
      bodyMap.put(msgType, supplier);
    }

    public boolean remove(Integer msgType) {
      return null != bodyMap.remove(msgType);
    }

    public static BodyMessageFactory getInstance() {
      return INSTANCE;
    }
  }
}
